#include "overlap_filter.hpp"

#include <cassert>
#include <algorithm>
#include <array>
#include <unordered_set>
#include <unordered_map>
#include <thread>
#include <sstream>
#include <iostream>
#include <regex>

#include "file_io.hpp"
#include "utility.hpp"

namespace fsa {

OverlapFilter::OverlapFilter() {
   
}

OverlapFilter::~OverlapFilter() {
}

bool OverlapFilter::ParseArgument(int argc, char *const argv[]) {
    return  GetArgumentParser().ParseArgument(argc, argv);
}

ArgumentParser OverlapFilter::GetArgumentParser() {
    ArgumentParser ap("fsa_ol_filter", "Filters out low-quality overlaps for assembling", "1.0");
    ap.AddNamedOption(min_length_, "min_length", " minimum length of reads");
    ap.AddNamedOption(max_length_, "max_length", "maximum length of reads");
    ap.AddNamedOption(min_identity_, "min_identity", " minimum identity of overlaps");
    ap.AddNamedOption(min_aligned_length_, "min_aligned_length", "minimum aligned length of overlaps");
    ap.AddNamedOption(max_overhang_, "max_overhang", " maximum overhang of overlaps, negative number = determined by the program.");
    ap.AddNamedOption(min_coverage_, "min_coverage", "minimum base coverage, negative number = determined by the program.");
    ap.AddNamedOption(max_coverage_, "max_coverage", "maximum base coverage, negative number = determined by the program");
    ap.AddNamedOption(max_diff_coverage_, "max_diff_coverage", "maximum difference of base coverage, negative number = determined by the program");
    ap.AddNamedOption(coverage_discard_, "coverage_discard", "discard ratio of base coverage. If max_coverage or max_diff_coverage is negative, it will be reset to (100-coverage_discard)th percentile.");
    ap.AddNamedOption(overlap_file_type_, "overlap_file_type", "overlap file format. \"\" = filename extension, \"m4\" = M4 format, \"paf\" = PAF format generated by minimap2, \"ovl\" = OVL format generated by FALCON.", "\"|m4|m4a|paf|ovl\"");
    ap.AddNamedOption(bestn_, "bestn", " output best n overlaps on 5' or 3' end for each read");
    //ap.AddNamedOption(genome_size_, "genome_size", "genome size, working with `--coverage` to determine the maximum length of reads", "\\d+[kKmMgG]?", ParamToGenomeSize);
    ap.AddNamedOption(genome_size_, "genome_size", "genome size. It determines the maximum length of reads with coverage together", "INT", ParamToGenomeSize);
    ap.AddNamedOption(coverage_, "coverage", "coverage. It determines the maximum length of reads with genome_size together");
    ap.AddNamedOption(output_directory_, "output_directory", "directory for output files");
    ap.AddNamedOption(thread_size_, "thread_size", "number of threads");

    ap.AddNamedOption(identity_global_deviation1_, "identity_global_deviation1", "If min_identity < 0, min_identity is set to min(m, deviation1) - 1.4826*mad*deviation2");
    ap.AddNamedOption(identity_global_deviation2_, "identity_global_deviation2", "If min_identity < 0, min_identity is set to min(m, deviation1) - 1.4826*mad*deviation2");

    ap.AddNamedOption(overhang_global_deviation1_, "overhang_global_deviation1", "If max_overhang < 0, max_overhang is set to max(m, deviation1) + 1.4826*mad*deviation2");
    ap.AddNamedOption(overhang_global_deviation2_, "overhang_global_deviation2", "If max_overhang < 0, max_overhang is set to max(m, deviation1) + 1.4826*mad*deviation2");

    ap.AddNamedOption(identity_local_deviation1_, "identity_local_deviation1", "The local threshold of identity is set to min(m, deviation1) - 1.4826*mad*deviation2");
    ap.AddNamedOption(identity_local_deviation2_, "identity_local_deviation2", "The local threshold of identity is set to min(m, deviation1) - 1.4826*mad*deviation2");
    ap.AddNamedOption(overhang_local_deviation1_, "overhang_local_deviation1", "The local threshold of overhang is set to max(m, deviation1) + 1.253*mad*deviation2");
    ap.AddNamedOption(overhang_local_deviation2_, "overhang_local_deviation2", "The local threshold of overhang is set to max(m, deviation1) + 1.253*mad*deviation2");
    ap.AddNamedOption(identity_local_condition_, "identity_local_condition", "Local filtering conditions. 0 = overlap idenitity < threshold, 1 = overlap idenitity < threshold and query identity >= target identity");

    ap.AddNamedOption(local_low_coverage_, "local_low_coverage", "If the coverage of reads is less than local_low_coverage, min_identity and max_overhang are used to filter out low-quality overlaps. Otherwise, the local threshold is used.");
    ap.AddPositionOption(ifname_, "overlaps", "input filename");
    ap.AddPositionOption(ofname_, "filtered_overlaps", "ouput filename");
    return ap;
}

void OverlapFilter::Usage() {
    std::cout << GetArgumentParser().Usage();
}


void OverlapFilter::Run() {
    LOG(INFO)("Start");
    
    PrintArguments();
    
    LOG(INFO)("Auto select parameters");
    AutoSelectParams();
    
    LOG(INFO)("Load overlap file");
    LoadOverlapsWithoutLowQuality(ifname_);
    //LoadOverlaps(ifname_);
    
    LOG(INFO)("Group overlaps and remove duplicated");
    GroupAndFilterDuplicateMt();

    LOG(INFO)("Filter low-quality overlaps");
    FilterLowQuality();

    LOG(INFO)("Check Coverage");
    FilterCoverageMt();

    LOG(INFO)("Check Support");
    FilterLackOfSupportMt();

    LOG(INFO)("Remove contained reads");
    FilterContainedMt();

    LOG(INFO)("Select BestN overlaps");
    FilterBestNMt();
    

    LOG(INFO)("Save Overlaps: %s", ofname_.c_str());
    SaveOverlaps(ofname_);

    LOG(INFO)("Dump");
    Dump();

    LOG(INFO)("End");
}

void OverlapFilter::LoadOverlaps(const std::string &fname) {
    auto filter_simple = [&](Overlap& o) {
        if (o.identity_ >= min_identity_raw_ && o.a_.id != o.b_.id &&
            o.a_.len >= min_length_ && o.b_.len >= min_length_ &&
            o.a_.len <= max_length_ && o.b_.len <= max_length_ &&
            (int)o.AlignedLength() >= min_aligned_length_ &&
            o.Location(max_overhang_raw_) != Overlap::Loc::Abnormal ) {

            return true;
        } else {
            return false;
        }
    };

    ol_store_.Load(fname, overlap_file_type_, (size_t)thread_size_, filter_simple);

    if (ol_store_.Size() > 0) {
        LOG(INFO)("Overlap size: %zd", ol_store_.Size());
    } else {
        LOG(FATAL)("No overlap was loaded");
    }
}

void OverlapFilter::LoadOverlapsWithoutLowQuality(const std::string &fname) {
    auto filter_simple = [&](Overlap& o) {
        if (o.identity_ >= min_identity_ && o.a_.id != o.b_.id &&
            o.a_.len >= min_length_ && o.b_.len >= min_length_ &&
            o.a_.len <= max_length_ && o.b_.len <= max_length_ &&
            (int)o.AlignedLength() >= min_aligned_length_ &&
            o.Location(max_overhang_) != Overlap::Loc::Abnormal ) {

            
            auto ath = read_infos_[o.a_.id].identity_threshold;
            auto bth = read_infos_[o.b_.id].identity_threshold;
            if (identity_local_condition_ == 0) {
                if (o.identity_ < ath || o.identity_ < bth) {
                    return false;
                }
            } else {
                if (o.identity_ < ath && o.identity_ < bth) {
                    return false;
                }
            }

            
            auto oh = o.Overhang2();
            if (oh[0] != 0) {
                auto &ri = read_infos_[o.a_.id];

                if (oh[0] & 0x01) {
                    if (o.a_.start - 0 > ri.overhang_l_threshold) {
                        return false;
                    }
                }
                if (oh[0] & 0x02) {
                    if (o.a_.len - o.a_.end > ri.overhang_r_threshold) {
                        return false;
                    }
                }
            }

            if (oh[1] != 0) {
                auto &ri = read_infos_[o.b_.id];

                if (oh[1] & 0x01) {
                    if (o.b_.start - 0 > ri.overhang_l_threshold) {
                        return false;
                    }
                }
                if (oh[1] & 0x02) {
                    if (o.b_.len - o.b_.end > ri.overhang_r_threshold) {
                        return false;
                    }
                }

            }
            
            return true;
        } else {
            return false;
        }
    };

    ol_store_.Load(fname, overlap_file_type_, (size_t)thread_size_, filter_simple);

    if (ol_store_.Size() > 0) {
        LOG(INFO)("Overlap size: %zd", ol_store_.Size());
    } else {
        LOG(FATAL)("No overlap was loaded");
    }
}

void OverlapFilter::SaveOverlaps(const std::string &fname) {
    
    auto filter = [&](const Overlap& o)->bool {
        return GetOlReason(o).type == OlReason::RS_OK;
        // MMM
        // return reserved_overlaps_.find(&o) != reserved_overlaps_.end();
    };

    ol_store_.Save(fname, overlap_file_type_, filter);
}

void OverlapFilter::StatLowQuality() {
    std::mutex mutex;

    std::list<std::unordered_map<Seq::Id, ReadStatInfo>> listReadInfos;

    auto alloc_readinfos = [&listReadInfos, &mutex]() -> std::unordered_map<Seq::Id, ReadStatInfo>& {
        std::lock_guard<std::mutex> lock(mutex);
        listReadInfos.push_back(std::unordered_map<Seq::Id, ReadStatInfo>());
        return listReadInfos.back();
    };

    MultiThreadRun(thread_size_, groups_, 
        SplitMapKeys<decltype(groups_)>, 
        [&](const std::vector<Seq::Id>& input){
            auto thread_local &infos = alloc_readinfos();
            for (auto i : input) {
                infos[i] = CalcReadInfo(i, groups_[i]);
            }
        }
    ); 

    for (auto &ri : listReadInfos) {
        read_infos_.insert(std::make_move_iterator(ri.begin()), std::make_move_iterator(ri.end()));
    }



    if (genome_size_ > 0 && coverage_ < 0) {
        long long total = std::accumulate(read_infos_.begin(), read_infos_.end(), (long long)0, [this](long long a, const std::pair<const int, ReadStatInfo>& b) {
            return a + b.second.len;
        });
        coverage_ = total / genome_size_;
        LOG(INFO)("Actual coverage = %d",  coverage_);
    }

    if (min_identity_ < 0) {
        auto stat = StatIdentity(read_infos_, identity_global_deviation1_);

        min_identity_ = std::min(identity_global_deviation1_, stat[0]) - identity_global_deviation2_ * 1.4826*stat[1];
     
        if (min_identity_ < 90.0) {
            LOG(WARNING)("Estimated min_identity is less than 90.0");
            min_identity_ = 90.0;
        }
        LOG(INFO)("Auto select min_identity = %f", min_identity_);
    }

    if (max_overhang_ < 0) {
        auto stat = StatOverhang(read_infos_, overhang_global_deviation1_);

        max_overhang_ = std::max(overhang_global_deviation1_, stat[0]) + overhang_global_deviation2_ * 1.4826* stat[1];


        if (max_overhang_ > 500) {
            LOG(WARNING)("Estimated max_overhang_ is greater than 500");
            max_overhang_ = 500;
        }
        LOG(INFO)("Auto select max_overhang = %d", max_overhang_);
    } else {
        // overhang_limit = overhang_limit;
    }

    overhang_limit = 0;//max_overhang_;
  
    MultiThreadRun(thread_size_, groups_, 
        SplitMapKeys<decltype(groups_)>, 
        [&](const std::vector<Seq::Id>& input){
            for (auto i : input) {
                CalcLocalThreshold(i, groups_[i]);
            }
        }
    ); 

}

void OverlapFilter::FilterLowQuality() {
    //StatLowQuality();

    MultiThreadRun(thread_size_, 
        [this]() {
            return SplitRange(thread_size_, (size_t)0, ol_store_.Size());
        }, 
        [this](const std::array<size_t, 2> &range) {
            for (size_t i=range[0]; i<range[1]; ++i) {
                FilterLowQuality(ol_store_.Get(i));
            }
        }
    );
    
    MultiThreadRun(thread_size_, 
        [this]() {
            return SplitRange(thread_size_, (size_t)0, ol_store_.Size());
        }, 
        [this](const std::array<size_t, 2> &range) {
            for (size_t i=range[0]; i<range[1]; ++i) {
                const Overlap& o = ol_store_.Get(i);
                if (IsReserved(o)) {
                    auto oh = o.Overhang();
                    int th = std::max(oh[0], oh[1]);
                    if (th > 0) {
                        ModifyEnd(o, th);
                    }
                }
            }
        }
    );
}


void OverlapFilter::FilterLowQuality(const Overlap &o) {
    if (IsReserved(o)) {
        auto ath = read_infos_[o.a_.id].identity_threshold;
        auto bth = read_infos_[o.b_.id].identity_threshold;
        if (identity_local_condition_ == 0) {
            if (o.identity_ < ath || o.identity_ < bth) {
                SetOlReason(o, OlReason::Local((int)(o.identity_*100), (int)(std::max(ath, bth)*100)));
            }
        } else {
            if (o.identity_ < ath && o.identity_ < bth) {
                SetOlReason(o, OlReason::Local((int)(o.identity_*100), (int)(std::min(ath, bth)*100)));
            }

        }
    }

    if (IsReserved(o)) {
        auto oh = o.Overhang2();
        if (oh[0] != 0) {
            auto &ri = read_infos_[o.a_.id];

            if (oh[0] & 0x01) {
                if (o.a_.start - 0 > ri.overhang_l_threshold) {
                    SetOlReason(o, OlReason::Local(o.a_.start - 0, ri.overhang_l_threshold));
                }
            }
            if (oh[0] & 0x02) {
                if (o.a_.len - o.a_.end > ri.overhang_r_threshold) {
                    SetOlReason(o, OlReason::Local(o.a_.len - o.a_.end, ri.overhang_r_threshold));
                }
            }
        }

        if (oh[1] != 0) {
            auto &ri = read_infos_[o.b_.id];

            if (oh[1] & 0x01) {
                if (o.b_.start - 0 > ri.overhang_l_threshold) {
                    SetOlReason(o, OlReason::Local(o.b_.start - 0, ri.overhang_l_threshold));
                }
            }
            if (oh[1] & 0x02) {
                if (o.b_.len - o.b_.end > ri.overhang_r_threshold) {
                    SetOlReason(o, OlReason::Local(o.b_.len - o.b_.end, ri.overhang_r_threshold));
                }
            }

        }
    }
}

OverlapFilter::ReadStatInfo OverlapFilter::CalcReadInfo(Seq::Id id, const std::unordered_map<Seq::Id, const Overlap*>& group) {
    ReadStatInfo info;
    std::vector<std::array<double,2>> identities;
    std::vector<std::array<double,2>> overhangs;

    for (auto &i : group) {
        auto& o = *i.second;
        
        auto& read = o.a_.id == id ? o.a_ : o.b_;
        info.len = read.len;
        identities.push_back({o.identity_, (double)(read.end-read.start)});

        auto overhang = o.Overhang();
        if (o.a_.id == id) {
            if (overhang[0] > 0) {
                overhangs.push_back(std::array<double,2>{double(overhang[0]), double(read.end - read.start)});
            }

        } else {
            if (overhang[1] > 0) {
                overhangs.push_back(std::array<double,2>{double(overhang[1]), double(read.end - read.start)});
            }
        }

    }
    info.count = identities.size();
    double median, mad;
    ComputeMeanAbsoluteDeviation(identities, median, mad);
    info.identity = median;
    if (overhangs.size() > 0) {
        auto e = *std::max_element(overhangs.begin(), overhangs.end(), [](const std::array<double,2>& a, const std::array<double,2>&b) {
            return a[0] < b[0];
        });
        //ComputeMedianAbsoluteDeviation(overhangs, median, mad);
        info.overhang = e[0];
    } 

    return info;
}

void OverlapFilter::CalcLocalThreshold(Seq::Id id, const std::unordered_map<Seq::Id, const Overlap*>& g) {
    
    // Collect identity and overhang
    std::vector<std::array<double,2>> identities;
    std::vector<std::array<double,2>> overhangs_l;   
    std::vector<std::array<double,2>> overhangs_r;
    for (auto &i : g) {
        const Overlap &o = *i.second;
        const Overlap::Read &read = o.a_.id == id ? o.a_ : o.b_;

        // if (IsReserved(o)) // check all overlaps 
        identities.push_back(std::array<double,2>{o.identity_, (double)read.end - read.start});

        auto oh = o.Overhang2();
        if (id == o.a_.id) {
            if (oh[0] & 0x01) {
                overhangs_l.push_back({(double)read.start-0, (double)read.end-read.start});
            }
            if (oh[0] & 0x02) {
                overhangs_r.push_back({(double)read.len-read.end, (double)read.end-read.start});
            }
        } else {
            assert(id == o.b_.id);
            if (oh[1] & 0x01) {
                overhangs_l.push_back({(double)read.start-0, (double)read.end-read.start});
            }
            if (oh[1] & 0x02) {
                overhangs_r.push_back({(double)read.len-read.end, (double)read.end-read.start});
            }
        }
        
    }

    int upper_limit = std::max(2*local_low_coverage_, (int)(coverage_*1.5));
    int lower_limit = local_low_coverage_;
    int base_upper_limit = upper_limit * read_infos_[id].len;
    int base_lower_limit = lower_limit * read_infos_[id].len;

  
    double identity_threshold = CalcLocalIdentityThreshold(identities, base_lower_limit, base_upper_limit);
    double overhang_l_threshold = CalcLocalOverhangThreshold(overhangs_l, lower_limit, upper_limit);
    double overhang_r_threshold = CalcLocalOverhangThreshold(overhangs_r, lower_limit, upper_limit);
 
    read_infos_[id].identity_threshold = identity_threshold;
    read_infos_[id].overhang_l_threshold = overhang_l_threshold;
    read_infos_[id].overhang_r_threshold = overhang_r_threshold;
    read_infos_[id].count = identities.size();
/*
    // filter the low-quialtiy overlaps
    for (auto &i : g) {
        const Overlap &o = *i.second;   
        const Overlap::Read &read = o.a_.id == id ? o.a_ : o.b_;

        if (o.identity_ < identity_threshold) {  
            
            if (identity_local_condition_ == 0) {
                SetOlReason(o, OlReason::Local((int)(o.identity_*100), (int)(identity_threshold*100)));
            } else {
                if (id == o.a_.id && read_infos_[o.a_.id].CompareIdentity(read_infos_[o.b_.id]) <= 0) {              
                    SetOlReason(o, OlReason::Local((int)(o.identity_*100), (int)(identity_threshold*100)));
                } else if (id == o.b_.id && read_infos_[o.b_.id].CompareIdentity(read_infos_[o.a_.id]) <= 0) {              
                    SetOlReason(o, OlReason::Local((int)(o.identity_*100), (int)(identity_threshold*100)));
                }
            }
        }

        auto oh = o.Overhang2();
        if (id == o.a_.id ) {
            if (oh[0] & 0x01) {
                if (read.start - 0 >overhang_l_threshold) {
                    SetOlReason(o, OlReason::Local(oh[0], overhang_l_threshold));
                }
            }
            if (oh[0] & 0x02) {
                if (read.len - read.end >overhang_r_threshold) {
                    SetOlReason(o, OlReason::Local(oh[0], overhang_r_threshold));
                }
            }
            
        } else {
            assert(id == o.b_.id);
            if (oh[1] & 0x01) {
                if (read.start - 0 >overhang_l_threshold) {
                    SetOlReason(o, OlReason::Local(oh[1], overhang_l_threshold));
                }
            }
            if (oh[1] & 0x02) {
                if (read.len - read.end >overhang_r_threshold) {
                    SetOlReason(o, OlReason::Local(oh[1], overhang_r_threshold));
                }

            }
        }
    }    
    */
}


double OverlapFilter::CalcLocalIdentityThreshold(std::vector<std::array<double,2>> &identities, int base_lower_limit, int base_upper_limit) {

    double identity_threshold = min_identity_;
    std::sort(identities.begin(), identities.end(), [](const std::array<double,2>& a, const std::array<double,2> &b){
        return a[0]*a[1] > b[0]*b[1];
    });

    size_t epos = 0;
    int base_accu = 0;
    for (; epos < identities.size(); ++epos) {
        base_accu += identities[epos][1];
        if (base_accu >= base_upper_limit) break;
    }
    
    if (base_accu >= base_lower_limit && epos > 0) {
        double median = 0;
        double mad = 0;
        std::vector<std::array<double,2>> idens(epos);
        std::transform(identities.begin(), identities.begin()+epos, idens.begin(),  [](const std::array<double,2> &a) {
            return std::array<double,2>({a[0], a[1]});
        });
        ComputeMedianAbsoluteDeviation(idens, median, mad);

        identity_threshold = std::min(identity_local_deviation1_, median) - identity_local_deviation2_*1.4826*mad; 
        identity_threshold = std::max(identity_threshold, min_identity_);
        
    }

    return identity_threshold;
}


double OverlapFilter::CalcLocalOverhangThreshold(std::vector<std::array<double,2>> &overhangs, int lower_limit, int upper_limit) {
        
    std::sort(overhangs.begin(), overhangs.end(), [](const std::array<double,2>& a, const std::array<double,2> &b){
        return  a[0]*1.0/ a[1] < b[0] *1.0/ b[1];
    });
    double overhang_threshold = max_overhang_;

    
    if ((int)overhangs.size() >= lower_limit) {
        double median = 0;
        double mad = 0;
        size_t size = std::min((int)overhangs.size(), upper_limit);
        std::vector<std::array<double,2>> ohs(size);
        std::transform(overhangs.begin(), overhangs.begin()+size, ohs.begin(),  [](const std::array<double,2> &a) {
            return std::array<double,2>({a[0], a[1]});
        });

        ComputeMedianAbsoluteDeviation(ohs, median, mad);
        if (mad >= 1.0e-10) {
            overhang_threshold = std::max(overhang_local_deviation1_, median) + overhang_local_deviation2_*1.4826*mad;
            overhang_threshold = std::min(overhang_threshold, (double)max_overhang_);

        } else {
            ComputeMeanAbsoluteDeviation(ohs, median, mad);
            overhang_threshold = std::max(overhang_local_deviation1_, median) + overhang_local_deviation2_*1.253*mad;
            overhang_threshold = std::min(overhang_threshold, (double)max_overhang_);
        }

    }
    return overhang_threshold;
}

void OverlapFilter::ModifyEnd(const Overlap &oldone, int maxoh) {
    if (oldone.Location(0) != Overlap::Loc::Abnormal) return;
    if (oldone.Location(maxoh) == Overlap::Loc::Abnormal) return;

    Overlap& o = const_cast<Overlap&>(oldone);
    if (o.a_.strand == o.b_.strand) {
        if (o.a_.start <= maxoh && o.b_.start <= maxoh) {
            o.a_.start = 0;
            o.b_.start = 0;
        }
        else if (o.a_.start <= maxoh) {
            o.b_.start -= o.a_.start;
            o.a_.start = 0;
        } 
        else if (o.b_.start <= maxoh) {
            o.a_.start -= o.b_.start;
            o.b_.start = 0;
        }

        if (o.a_.end >= o.a_.len - maxoh && o.b_.end >= o.b_.len - maxoh) {
            o.a_.end = o.a_.len;
            o.b_.end = o.b_.len;
        }
        else if (o.a_.end >= o.a_.len - maxoh) {
            o.b_.end += o.a_.len - o.a_.end;
            o.a_.end = o.a_.len;
        }
        else if (o.b_.end >= o.b_.len - maxoh) {
            o.a_.end += o.b_.len - o.b_.end;
            o.b_.end = o.b_.len;
        }

    }
    else {
        if (o.a_.start <= maxoh && o.b_.end >= o.b_.len - maxoh) {
            o.a_.start = 0;
            o.b_.end = o.b_.len;
        }
        else if (o.a_.start <= maxoh) {
            o.b_.end += o.a_.start;
            o.a_.start = 0;
        }
        else if (o.b_.end >= o.b_.len - maxoh) {
            o.a_.start -= o.b_.len - o.b_.end;
            o.b_.end = o.b_.len;
        }

        if (o.b_.start <= maxoh && o.a_.end >= o.a_.len - maxoh) {
            o.b_.start = 0;
            o.a_.end = o.a_.len;
        }
        else if (o.b_.start <= maxoh) {
            o.a_.end += o.b_.start;
            o.b_.start = 0;

        }
        else if (o.a_.end >= o.a_.len - maxoh) {
            o.b_.start -= o.a_.len - o.a_.end;
            o.a_.end = o.a_.len;
        }
    }

    assert(o.Location(0) != Overlap::Loc::Abnormal);

}

void OverlapFilter::FilterContained() {

    std::unordered_map<int, RdReason> ignored;    
    std::vector<const Overlap*> noSup;


    for (auto &o : ol_store_.Get()) {
        if (IsReserved(o)) {
            std::array<int,2> rel;
            if (IsContained(o, rel)) {
                if (IsSupportContained(o, rel)) {
                    ignored.insert(std::make_pair(rel[0], RdReason::Contained(rel[1])));

                } else {
                    noSup.push_back(&o);
                }
            }
        }
    }

    for (auto o : noSup) {
        SetOlReason(*o, OlReason::LackOfSupport());
    }

    UpdateFilteredRead(ignored);
    filtered_reads_.insert(ignored.begin(), ignored.end());

}


void OverlapFilter::FilterContainedMt() {
    std::mutex mutex;       // Lock filtered_reads_

    std::vector<const Overlap*> noSups;

    auto split_func = [this]() {
        return SplitRange(thread_size_, (size_t)0, ol_store_.Size());
    };

    auto comb_func = [this, &mutex](const std::vector<std::array<int,2>> &rels) {
        std::lock_guard<std::mutex> lock(mutex);
        for (auto &rel : rels) 
            filtered_reads_.insert(std::make_pair(rel[0], RdReason::Contained(rel[1])));
    };

    auto work_func = [&](const std::array<size_t, 2> &range) {
        std::vector<std::array<int,2>> rels;
        
        for (size_t i=range[0]; i<range[1]; ++i) {
            const Overlap& o = ol_store_.Get(i);
            std::array<int, 2> rel;

            if (IsReserved(o) && IsContained(o, rel)) {
                rels.push_back(rel);
            }
        }

        comb_func(rels);
    };

    MultiThreadRun(thread_size_, split_func, work_func);

    UpdateFilteredRead(filtered_reads_);

}


void OverlapFilter::FilterCoverage() {

    for (auto &g : groups_) {
        auto minmax = CalcMinMaxCoverage(g.first, g.second);
        coverages_.insert(std::make_pair(g.first, std::array<int,2>{minmax.first, minmax.second}));
    }
    
       
    coverage_params_ = CoverageParam();
    FilterCoverage(coverage_params_[0], coverage_params_[1], coverage_params_[2]);
}


void OverlapFilter::FilterCoverageMt() {
    auto work_func = [&](const std::vector<int>& input) -> std::unordered_map<int, std::array<int, 2>> {
        std::unordered_map<int, std::array<int, 2>> output;
        
        for (auto i : input) {
            auto minmax = CalcMinMaxCoverage(i, groups_[i]);
            output.insert(std::make_pair(i, std::array<int,2>{minmax.first, minmax.second}));
        }
        return output;
    };

    coverages_ = MultiThreadRun(thread_size_, groups_, 
        SplitMapKeys<decltype(groups_)>, 
        work_func, 
        MoveCombineMapOrSet<std::unordered_map<int, std::array<int, 2>>>);   
    coverage_params_ = CoverageParam1();
    DumpCoverage(OutputPath("coverage0.txt.gz"));
    FilterCoverage(coverage_params_[0], coverage_params_[1], coverage_params_[2]);


    coverages_ = MultiThreadRun(thread_size_, groups_, 
        SplitMapKeys<decltype(groups_)>, 
        work_func, 
        MoveCombineMapOrSet<std::unordered_map<int, std::array<int, 2>>>);   
    auto coverage_params = CoverageParam1();
    FilterCoverage(coverage_params[0], coverage_params_[1], coverage_params_[2]);
    
}

void OverlapFilter::FilterLackOfSupport() {

    std::unordered_set<const Overlap*> ignored;
    for (const auto &o : ol_store_.Get()) {
        if (IsReserved(o) && !HasSupport(o, std::max(0, int(coverage_params_[0]-1)))) {
            ignored.insert(&o);
        }
    }
   for (auto o : ignored) {
       SetOlReason(*o, OlReason::LackOfSupport());
   }
}

void OverlapFilter::FilterLackOfSupportMt() {
    auto split_func = [this](size_t size, const std::array<size_t,2> &range) {
        return SplitRange(thread_size_, range[0], range[1]);
    };

    auto work_func = [&](const std::array<size_t, 2> &range)->std::unordered_set<const Overlap*> {
        
        std::unordered_set<const Overlap*> ignored;
        for (size_t i=range[0]; i<range[1]; ++i) {
            const Overlap& o = ol_store_.Get(i);
            if (IsReserved(o) && !HasSupport(o, std::max(0, int(coverage_params_[0]-1)))) {
                ignored.insert(&o);
            }
        }
        return ignored;
    };

   auto ignored = MultiThreadRun((size_t)thread_size_, std::array<size_t,2>{(size_t)0, ol_store_.Size()}, split_func, work_func, MoveCombineMapOrSet<std::unordered_set<const Overlap*>>);
   for (auto o : ignored) {
       SetOlReason(*o, OlReason::LackOfSupport());
   }
}




void OverlapFilter::FilterBestN() {
    std::unordered_set<const Overlap*> keep;
    for (auto &g : groups_) {
        auto k = FindBestN(g);
        keep.insert(k.begin(), k.end());
        
    }

    for (const auto &o : ol_store_.Get()) {
        if (IsReserved(o) && keep.find(&o) == keep.end()) {
            SetOlReason(o, OlReason::BestN());
        }

    }
}


void OverlapFilter::FilterBestNMt() {
    auto work_func = [&](const std::vector<int> &input) {
        
        std::unordered_set<const Overlap*> output;
        for (auto &i : input) {
            if (filtered_reads_.find(i) == filtered_reads_.end()) {
                auto g = groups_.find(i);
                assert(g != groups_.end());
                auto k = FindBestN(*g);

                output.insert(k.begin(), k.end());
            }
            
        }
        return output;
    };


    auto keep = MultiThreadRun(thread_size_, groups_, 
        SplitMapKeys<decltype(groups_)>, 
        work_func, 
        MoveCombineMapOrSet<std::unordered_set<const Overlap*>>);

    for (const auto &o : ol_store_.Get()) {
        if (IsReserved(o) && keep.find(&o) == keep.end()) {
            SetOlReason(o, OlReason::BestN());
        }

    }

}


void OverlapFilter::AutoSelectParams() {
    std::mutex mutex;

    size_t block_size = 50000;

    struct IdentityInfo {
        float identity;
        int32_t len;
        int32_t alen;   // aligned len
    };

    struct OverhangInfo {
        std::array<int16_t, 2> overhang;    // left and right;
        int32_t len;
        int32_t alen;   // aligned len
    };

    struct ReadInfo {
        int len;
        std::vector<IdentityInfo> identities;
        std::vector<OverhangInfo> overhangs;
    };

    struct WorkArea{
        std::unordered_map<int, ReadInfo> readinfos;
        void Clear() { readinfos.clear(); }
    };
    

    std::unordered_map<int, ReadInfo> readinfos;

    std::list<WorkArea> works;  // for each thread. Vector may cause memory reallocating, so list is used.

    auto alloc_work = [&]() -> WorkArea& {
        std::lock_guard<std::mutex> lock(mutex);
        works.push_back(WorkArea());

        return works.back();
    };

    auto combine = [&](WorkArea& work) {
        std::lock_guard<std::mutex> lock(mutex);
        for (auto &ri : work.readinfos) {
            auto iter = readinfos.find(ri.first);
            if (iter != readinfos.end()) {
                iter->second.identities.insert(iter->second.identities.end(), std::make_move_iterator(ri.second.identities.begin()), std::make_move_iterator(ri.second.identities.end()));
                iter->second.overhangs.insert(iter->second.overhangs.end(), std::make_move_iterator(ri.second.overhangs.begin()), std::make_move_iterator(ri.second.overhangs.end()));
            } else {
                readinfos.insert(ri);
            }
        }
        work.Clear();
    };


    auto scan_overlap = [&](Overlap& o) {
        WorkArea thread_local &work = alloc_work();
        if (o.identity_ >= min_identity_raw_ && o.Location(max_overhang_raw_) != Overlap::Loc::Abnormal &&
            (int)o.AlignedLength() >= min_aligned_length_) {

            work.readinfos[o.a_.id].len = o.a_.len;
            work.readinfos[o.b_.id].len = o.b_.len;

            work.readinfos[o.a_.id].identities.push_back({(float)o.identity_, o.b_.len, o.a_.end - o.a_.start});
            work.readinfos[o.b_.id].identities.push_back({(float)o.identity_, o.a_.len, o.b_.end - o.b_.start});
            
            auto oh = o.Overhang2();
            if (oh[0] != 0) {
                int16_t loh = (oh[0] & 0x1) == 0 ? -1 : o.a_.start - 0;
                int16_t roh = (oh[0] & 0x2) == 0 ? -1 : o.a_.len - o.a_.end;
                work.readinfos[o.a_.id].overhangs.push_back({{loh, roh}, o.b_.len, o.a_.end - o.a_.start});
            }
            if (oh[1] != 0) {
                int16_t loh = (oh[1] & 0x1) == 0 ? -1 : o.b_.start - 0;
                int16_t roh = (oh[1] & 0x2) == 0 ? -1 : o.b_.len - o.b_.end;
                work.readinfos[o.b_.id].overhangs.push_back({{loh, roh}, o.a_.len, o.b_.end - o.b_.start});
            }
        }
        if (work.readinfos.size() >= block_size) {
            combine(work);
        }
        return false;   // not load to memory
    };

    OverlapStore ol;
    ol.Load(ifname_, "", thread_size_, scan_overlap);
    for (auto & w : works) {
        combine(w);
    }

    if (genome_size_ > 0 && coverage_ > 0) {
        std::vector<int> lengths(readinfos.size());
        std::transform(readinfos.begin(), readinfos.end(), lengths.begin(), [](const std::pair<int,ReadInfo> &kv) {
            return kv.second.len;
        });
        AutoSelectMinLength(lengths);
    }

    if (max_overhang_ < 0 || min_identity_ < 0) {
        for (const auto & ri : readinfos) {
            if (ri.second.len >= min_length_) {
                std::vector<std::array<double,2>> identities;
                std::vector<std::array<double,2>> overhangs;
                for (auto &iden : ri.second.identities) {
                    if (iden.len >= min_length_) {
                        identities.push_back({(double)iden.identity, (double)(iden.alen)});
                    }
                }

                for (auto &oh : ri.second.overhangs) {
                    if (oh.len >= min_length_) {
                        overhangs.push_back({(double)std::max(oh.overhang[0], oh.overhang[1]), (double)oh.alen});
                    }
                }

                if (identities.size() > 0) {
                    ReadStatInfo info;
                    info.count = identities.size();
                    info.len = ri.second.len;
                    double median, mad;
                    ComputeMeanAbsoluteDeviation(identities, median, mad);
                    info.identity = median;
                    if (overhangs.size() > 0) {
                        auto e = *std::max_element(overhangs.begin(), overhangs.end(), [](const std::array<double,2>& a, const std::array<double,2>&b) {
                            return a[0] < b[0];
                        });
                        info.overhang = e[0];

                    }

                    read_infos_[ri.first] = info;
                }
            }
        }
        
        if (min_identity_ < 0) {
            min_identity_ = CalcMinIdentity(read_infos_, identity_global_deviation1_, identity_global_deviation2_, 90.0);
        }
        if (max_overhang_ < 0) {
            max_overhang_ = CalcMaxOverhang(read_infos_, overhang_global_deviation1_, overhang_global_deviation2_, 500);
        }
    }

    for (auto &ri : read_infos_) {
        assert(ri.second.len >= min_length_);
        int upper_limit = std::max(2*local_low_coverage_, (int)(coverage_*1.5));
        int lower_limit = local_low_coverage_;
        int base_upper_limit = upper_limit * ri.second.len;
        int base_lower_limit = lower_limit * ri.second.len;

        auto rri = readinfos.find(ri.first);
        assert(rri != readinfos.end());

        std::vector<std::array<double,2>> identities;
        
        for (auto &i : rri->second.identities) {
            if (i.len >= min_length_) {
            //if (i.len >= min_length_ && i.identity >= min_identity_) {
                identities.push_back(std::array<double,2>{i.identity, (double)i.alen});
            }
        }
        ri.second.identity_threshold = CalcLocalIdentityThreshold(identities, base_lower_limit, base_upper_limit);

        std::vector<std::array<double,2>> overhangs_l;   
        std::vector<std::array<double,2>> overhangs_r;
        for (auto &i : rri->second.overhangs) {
            if (i.len >= min_length_) {
                if (i.overhang[0] >= 0) {
                //if (i.overhang[0] >= 0 && i.overhang[0] <= max_overhang_) {
                    overhangs_l.push_back({(double)i.overhang[0], (double)i.alen});
                }
                if (i.overhang[1] >= 0) {
                //if (i.overhang[1] >= 0 && i.overhang[1] <= max_overhang_) {
                    overhangs_r.push_back({(double)i.overhang[1], (double)i.alen});
                }
            }
        }

        ri.second.overhang_l_threshold = CalcLocalOverhangThreshold(overhangs_l, lower_limit, upper_limit);
        ri.second.overhang_r_threshold = CalcLocalOverhangThreshold(overhangs_r, lower_limit, upper_limit);
        
    }
    DumpReadInfos(OutputPath("readinfos.gz"), read_infos_);
}

void OverlapFilter::AutoSelectMinLength(std::vector<int> &lengths) {
    
    assert(genome_size_ > 0 && coverage_ > 0);
    
    size_t i = FindLongestXHeap(lengths, genome_size_*coverage_);
    if (i < lengths.size()) {
        if (min_length_ < lengths[i]) {
            min_length_ = lengths[i];
        }
    } else {
        auto m = std::min_element(lengths.begin(), lengths.end());
        if (min_length_ < *m) {
            min_length_ = *m;
        } 

        long long total = std::accumulate(lengths.begin(), lengths.end(), (long long)0, [this](long long a, int b) {
            return a + (b >= min_length_ ? b : 0);
        });

       coverage_ = total / genome_size_;
        
        LOG(INFO)("Actual coverage = %d",  coverage_);

    }
    
    LOG(INFO)("Auto Select min_length = %d ", min_length_);

}


double OverlapFilter::CalcMinIdentity(const std::unordered_map<Seq::Id, ReadStatInfo>& readinfos, double dev1, double dev2, double minvalue) {
    
    auto stat = StatIdentity(readinfos, dev1);

    double min_iden = std::min(dev1, stat[0]) - dev2 * 1.4826*stat[1];
     
    if (min_iden < minvalue) {
        LOG(WARNING)("Estimated min_identity is less than %.01f", minvalue);
        min_iden = minvalue;
    }
    LOG(INFO)("Auto select min_identity = %f", min_iden);
    return min_iden;
}

int OverlapFilter::CalcMaxOverhang(const std::unordered_map<Seq::Id, ReadStatInfo>& readinfos, double dev1, double dev2, int maxvalue) {
    
    auto stat = StatOverhang(readinfos, dev1);
    int max_oh = std::max(dev1, stat[0]) + dev2 * 1.4826* stat[1];


    if (max_oh > maxvalue) {
        LOG(WARNING)("Estimated max_overhang_ is greater than %d", maxvalue);
        max_oh = maxvalue;
    }
    LOG(INFO)("Auto select max_overhang = %d", max_oh);
    return max_oh;
}



std::array<double,2> OverlapFilter::StatIdentity(const std::unordered_map<Seq::Id, ReadStatInfo> &readInfos, int n) {
    std::vector<std::array<double,2>> idents(readInfos.size());
    std::transform(readInfos.begin(), readInfos.end(), idents.begin(), [&](const std::pair<int,ReadStatInfo> &kv) {
        return std::array<double,2>{kv.second.identity, (double)kv.second.len/1000.0}; 
        //return std::array<double,2>{kv.second.identity, 1.0}; 
    });

    std::sort(idents.begin(), idents.end(), [](const std::array<double,2>& a, const std::array<double,2>&b) { return a[0] > b[0];} );

    double median = 0;
    double mad = 0;
    ComputeMedianAbsoluteDeviation(idents, median, mad);
    LOG(INFO)("Stat identity median=%f, mad=%f", median, mad);
    //return median - n*1.4826*mad;
    return {median, mad};
}

std::array<double,2>  OverlapFilter::StatOverhang(const std::unordered_map<Seq::Id, ReadStatInfo> &readInfos, int n) {
    std::vector<std::array<double,2>> overhangs(readInfos.size());
    std::transform(readInfos.begin(), readInfos.end(), overhangs.begin(), [&](const std::pair<int,ReadStatInfo> &kv) {
        return std::array<double,2>{(double)kv.second.overhang, kv.second.len/1000.0};
        //return std::array<double,2>{(double)kv.second.overhang, 1.0};
    });

    std::sort(overhangs.begin(), overhangs.end(), [](const std::array<double,2>& a, const std::array<double,2>&b) { return a[0] < b[0];} );

    double median = 0;
    double mad = 0;
    ComputeMedianAbsoluteDeviation(overhangs, median, mad);
    LOG(INFO)("Stat overhang: median=%f, mad=%f", median, mad);
    //return (int)(median + n*1.4826*mad);
    return {median, mad};
}


void OverlapFilter::GroupAndFilterDuplicate() {
    for (const auto &o : ol_store_.Get()) {
        if (IsReserved(o)) {

            auto add_overlap = [&](int a, int b, const Overlap& o) {
                auto iter = groups_.find(a);
                if (iter != groups_.end()) {
                    auto iteriter = iter->second.find(b);
                    if (iteriter == iter->second.end()) {
                        iter->second[b] = &o;
                    } else {
                        if (BetterAlignedLength(o, *(iteriter->second))) {
                            SetOlReason(*(iteriter->second), OlReason::Duplicate());
                            iteriter->second = &o;
                        } else {
                            SetOlReason(o, OlReason::Duplicate());

                        }
                    }
                }
                else {
                    auto iter = groups_.insert(std::make_pair(a, std::unordered_map<int, const Overlap*>()));
                    iter.first->second[b] = &o;
                }
            };

            add_overlap(o.a_.id, o.b_.id, o);
            add_overlap(o.b_.id, o.a_.id, o);
        }
    }
}

void OverlapFilter::GroupAndFilterDuplicateMt() {
    std::vector<std::pair<const Overlap*, OlReason>> ignored;
    std::mutex mutex;

    auto add_overlap = [](int low, int a, int b, const Overlap& o, std::vector<std::unordered_map<Seq::Id, const Overlap*>>& group) {
        
        auto it = group[a-low].find(b);
        if (it == group[a-low].end()) {
            group[a-low][b] = &o;
        } else {
            if (BetterAlignedLength(o, *(it->second))) {
                SetOlReason(*(it->second), OlReason::Duplicate());
                it->second = &o;
            } else {
                SetOlReason(o, OlReason::Duplicate());
            }
        }

    };

    auto split_func = [this]() {
        auto r = ol_store_.GetReadIdRange();
        return SplitRange(thread_size_, r[0], r[1]);
    };
    auto comb_func = [this, &ignored, &mutex](int low, std::vector<std::unordered_map<Seq::Id, const Overlap*>>&& group) {
        std::lock_guard<std::mutex> lock(mutex);
        for (size_t i=0; i<group.size(); ++i) {
            if (group[i].size() > 0) {
                groups_[low+(int)i] = std::move(group[i]);
            }

        }
    };

    auto work_func = [this, add_overlap, comb_func](std::array<Seq::Id, 2> r) {
        std::vector<std::unordered_map<Seq::Id, const Overlap*>> group(r[1] - r[0]);
        std::vector<std::pair<const Overlap*, OlReason>> ignored;

        for (const auto &o : ol_store_.Get()) {
            if (IsReserved(o)) {
                if (o.a_.id >= r[0] && o.a_.id < r[1]) {
                    add_overlap(r[0], o.a_.id, o.b_.id, o, group);
                }
                if (o.b_.id >= r[0] && o.b_.id < r[1]) {
                    add_overlap(r[0], o.b_.id, o.a_.id, o, group);
                }
            }
        }

        comb_func(r[0], std::move(group));
    };

    MultiThreadRun((int)thread_size_, split_func, work_func);

}


std::pair<int, int> OverlapFilter::CalcMinMaxCoverage(int id, const std::unordered_map<int, const Overlap*>& group) {
    if (group.size() > 0) {
        std::vector<int> cov((group.begin()->second->a_.id == id ? group.begin()->second->a_.len :
            group.begin()->second->b_.len) + 1, 0);

        for (const auto &ig : group) {
            const Overlap& o = *ig.second;
            if (IsReserved(o)) {
                if (o.a_.id == id) {
                    //cov[o.a_.start] ++;
                    //cov[o.a_.end] --;
                    cov[std::max(0, o.a_.start-overhang_limit)] ++;
                    cov[std::min(o.a_.len, o.a_.end+overhang_limit)] --;
                } else {
                    assert(o.b_.id == id);
                    //cov[o.b_.start] ++;
                    //cov[o.b_.end] --;
                    cov[std::max(0, o.b_.start-overhang_limit)] ++;
                    cov[std::min(o.b_.len, o.b_.end+overhang_limit)] --;

                }
            }
        }
        for (size_t i = 1; i < cov.size(); ++i) {
            cov[i] += cov[i - 1];
        }
        assert(cov.back() == 0);


        auto c_minmax = std::minmax_element(cov.begin(), cov.end()-1);
        return std::make_pair(*c_minmax.first, *c_minmax.second);

    }
    else {
        return std::make_pair(0, 0);
    }


}

void OverlapFilter::PrintArguments() {
    LOG(INFO)("Arguments: \n%s", GetArgumentParser().PrintOptions().c_str());
}


void OverlapFilter::FilterCoverage(int min_coverage, int max_coverage, int max_diff_coverge) {
    LOG(INFO)("min_coverage = %d, max_coverage = %d, max_diff_coverage = %d", min_coverage, max_coverage, max_diff_coverge);

    for (auto c : coverages_) {
        if (c.second[0] < min_coverage  || c.second[1] > max_coverage ||
            c.second[1] - c.second[0] > max_diff_coverge) {
            filtered_reads_.insert(std::make_pair(c.first, RdReason::Coverage(c.second)));
        }
    }

    UpdateFilteredRead(filtered_reads_);
}

std::array<int, 3> OverlapFilter::CoverageParam() const {
    std::array<int, 3> param { min_coverage_, max_coverage_, max_diff_coverage_};

    if (param[0] < 0 && coverages_.size() > 0) {
        auto minmaxv = std::minmax_element(coverages_.begin(), coverages_.end(), 
        [](const std::pair<const int, std::array<int,2>> &a, 
           const std::pair<const int, std::array<int,2>> &b) {
            return a.second[0] < b.second[0];
        });

        auto minv = (*minmaxv.first).second[0];
        auto maxv = (*minmaxv.second).second[0];

        std::vector<int> counts(maxv-minv+1, 0);
        for (auto c : coverages_) {
            counts[c.second[0]-minv]++;
        }

        
        int accu = 0;
        for (size_t i=0; i<counts.size(); ++i) {
            accu += counts[i];
            if (coverages_.size() * coverage_discard_ / 100 < accu) {
                param[0] = i + minv;
                break;
            }
        }
        

    }

    if (param[1] < 0 && coverages_.size() > 0) {
        auto minmaxv = std::minmax_element(coverages_.begin(), coverages_.end(), 
        [](const std::pair<const int, std::array<int,2>> &a, 
           const std::pair<const int, std::array<int,2>> &b) {
            return a.second[1] < b.second[1];
        });

        auto minv = (*minmaxv.first).second[1];
        auto maxv = (*minmaxv.second).second[1];

        std::vector<int> counts(maxv-minv+1, 0);
        for (auto c : coverages_) {
            counts[c.second[1]-minv]++;
        }

        int accu = 0;
        for (size_t i=counts.size(); i>0; --i) {
            accu += counts[i-1];
            if (coverages_.size() * coverage_discard_ / 100< accu) {
                param[1] = i-1 + minv;
                break;
            }
        }
    }

    if (param[2] < 0 && coverages_.size() > 0) {
        auto minmaxv = std::minmax_element(coverages_.begin(), coverages_.end(), 
        [](const std::pair<const int, std::array<int,2>> &a, 
           const std::pair<const int, std::array<int,2>> &b) {
            return a.second[1]-a.second[0] < b.second[1]-b.second[0];
        });

        auto minv = (*minmaxv.first).second[1]-(*minmaxv.first).second[0];
        auto maxv = (*minmaxv.second).second[1]-(*minmaxv.second).second[0];

        std::vector<int> counts(maxv-minv+1, 0);
        for (auto c : coverages_) {
            counts[c.second[1]-c.second[0]-minv]++;
        }

        int accu = 0;
        for (size_t i=counts.size(); i>0; --i) {
            accu += counts[i-1];
            if (coverages_.size() * coverage_discard_ / 100 < accu) {
                param[2] = i-1 + minv;
                break;
            }
        }
    }

    return param;
}


std::array<int, 3> OverlapFilter::CoverageParam1() const {
    std::array<int, 3> param { min_coverage_, max_coverage_, max_diff_coverage_};

    std::vector<int> cov(coverages_.size());
    if (param[0] < 0 && coverages_.size() > 0) {
        std::transform(coverages_.begin(), coverages_.end(), cov.begin(), [](const decltype(coverages_)::value_type& a) {
            return a.second[0];
        });

        param[0] = FirstTrough(cov, 100, 9);
        //param[0] = Percentile(cov, coverage_percent_);
    }


    if (param[1] < 0 && coverages_.size() > 0) {
        std::transform(coverages_.begin(), coverages_.end(), cov.begin(), [](const decltype(coverages_)::value_type& a) {
            return a.second[1];
        });

        param[1] = Percentile(cov, 100-coverage_discard_);
    }

    

    if (param[2] < 0 && coverages_.size() > 0) {
        std::transform(coverages_.begin(), coverages_.end(), cov.begin(), [](const decltype(coverages_)::value_type& a) {
            return a.second[1]-a.second[0];
        });

        param[2] = Percentile(cov, 100-coverage_discard_);
    }

    return param;
}

size_t OverlapFilter::FindLongestXHeap(std::vector<std::array<int,2>> &lengths, long long goal) {

    long long accu = 0;
    size_t index = 0;
    auto cmp = [](const std::array<int, 2>&a, const std::array<int,2> &b) {
        return a[1] > b[1];
    };
    for (size_t i = 0; i< lengths.size(); ++i) {
        if (accu < goal || lengths[0][1] < lengths[i][1]) {
            accu += lengths[i][1];
            std::swap(lengths[index], lengths[i]);
            index++;
            std::push_heap(lengths.begin(), lengths.begin()+index, cmp);
        }

        while (accu - lengths[0][1] >= goal) {
            accu -= lengths[0][1];
            std::pop_heap(lengths.begin(), lengths.begin()+index, cmp);
            index--;
        
        }
    }

    return index;
}

size_t OverlapFilter::FindLongestXHeap(std::vector<int> &lengths, long long goal) {

    long long accu = 0;
    size_t index = 0;
    auto cmp = [](int a, int b) {
        return a > b;
    };
    for (size_t i = 0; i< lengths.size(); ++i) {
        if (accu < goal || lengths[0] < lengths[i]) {
            accu += lengths[i];
            std::swap(lengths[index], lengths[i]);
            index++;
            std::push_heap(lengths.begin(), lengths.begin()+index, cmp);
        }

        while (accu - lengths[0] >= goal) {
            accu -= lengths[0];
            std::pop_heap(lengths.begin(), lengths.begin()+index, cmp);
            index--;
        
        }
    }

    return index;
}

size_t OverlapFilter::FindLongestXSort(std::vector<std::array<int,2>> &lengths, long long goal) {

    long long accu = 0;
    auto cmp = [](const std::array<int, 2>&a, const std::array<int,2> &b) {
        return a[1] > b[1];
    };

    std::sort(lengths.begin(), lengths.end(), cmp);

    for (size_t i = 0; i< lengths.size(); ++i) {
        if (accu < goal) {
            accu += lengths[i][1];
        } else {
            return i;
        }
    }

    return lengths.size();
}

bool OverlapFilter::HasSupport(const Overlap &o, int count) const {

    bool r = false;
    Overlap::Loc loc = o.Location(0);  // Because modified the Ends, err could be set 0

    const int maxoh = 2000; // 2*max_overhang_;
    int a_head = o.a_.start;
    int a_tail = o.a_.len - o.a_.end;
    int b_head = o.b_.start;
    int b_tail = o.b_.len - o.b_.end;
    if (o.SameDirect()) {
        
        if (loc == Overlap::Loc::Left) {

            r = HasAlignment(o.a_.id, o.b_.id, 1, count, b_tail > maxoh) && HasAlignment(o.b_.id, o.a_.id, 0, count, a_head > maxoh);
        } else if (loc == Overlap::Loc::Right) {
            r = HasAlignment(o.a_.id, o.b_.id, 0, count, b_head > maxoh) && HasAlignment(o.b_.id, o.a_.id, 1, count, a_tail > maxoh);
        } else if (loc == Overlap::Loc::Containing) {
            r = HasAlignment(o.b_.id, o.a_.id, 0, count, a_head > maxoh) && HasAlignment(o.b_.id, o.a_.id, 1, count, a_tail > maxoh);
        } else if (loc == Overlap::Loc::Contained) {
            r = HasAlignment(o.a_.id, o.b_.id, 0, count, b_head > maxoh) && HasAlignment(o.a_.id, o.b_.id, 1, count, b_tail > maxoh);
        } else if (loc == Overlap::Loc::Equal) {
            r = HasAlignment(o.a_.id, o.b_.id, 0, count, false) && HasAlignment(o.a_.id, o.b_.id, 1, count, false) &&
                HasAlignment(o.b_.id, o.a_.id, 0, count, false) && HasAlignment(o.b_.id, o.a_.id, 1, count, false);
        } else {
            assert("Never Come here");
        }

    } else {
        if (loc == Overlap::Loc::Left) {
            r = HasAlignment(o.a_.id, o.b_.id, 0, count, b_tail > maxoh) && HasAlignment(o.b_.id, o.a_.id, 0, count, a_tail > maxoh);
        } else if (loc == Overlap::Loc::Right) {
            r = HasAlignment(o.a_.id, o.b_.id, 1, count, b_head > maxoh) && HasAlignment(o.b_.id, o.a_.id, 1, count, a_head > maxoh);
        } else if (loc == Overlap::Loc::Containing) {
            r = HasAlignment(o.b_.id, o.a_.id, 0, count, a_tail > maxoh) && HasAlignment(o.b_.id, o.a_.id, 1, count, a_head > maxoh);
        } else if (loc == Overlap::Loc::Contained) {
            r = HasAlignment(o.a_.id, o.b_.id, 0, count, b_tail > maxoh) && HasAlignment(o.a_.id, o.b_.id, 1, count, b_head > maxoh);
        } else if (loc == Overlap::Loc::Equal) {
            r = HasAlignment(o.a_.id, o.b_.id, 0, count, false) && HasAlignment(o.a_.id, o.b_.id, 1, count, false) &&
                HasAlignment(o.b_.id, o.a_.id, 0, count, false) && HasAlignment(o.b_.id, o.a_.id, 1, count, false);
        } else {
            assert("Never Come here");
        }
    }
    
    return r;
}

bool OverlapFilter::HasAlignment(int a, int b, int end, int count, bool exceeding) const {
    auto agroup = groups_.find(a);
    auto bgroup = groups_.find(b);

    assert(agroup != groups_.end() && bgroup != groups_.end());
    int at0 = 0;
    int at1 = 0;
    int reserved_at0 = 0;
    int reserved_at1 = 0;
    for (const auto &i : agroup->second) {
        //if (i.first == b || !IsReserved(*i.second)) continue; // skip self
        if (i.first == b ) continue; // skip self

        if (end == 0) {
            bool qualified = false;
            
            if (exceeding) {
                if (i.second->SameDirect()) {
                    qualified = i.second->a_.id == a ? i.second->b_.start > max_overhang_ 
                                                     : i.second->a_.start > max_overhang_;
                } else {
                    qualified = i.second->a_.id == a ? i.second->b_.len - i.second->b_.end > max_overhang_ 
                                                     : i.second->a_.len - i.second->a_.end > max_overhang_;
                }
            } else {
                qualified = i.second->a_.id == a ? i.second->a_.start <= max_overhang_ 
                                                 : i.second->b_.start <= max_overhang_;
            }
            auto inbgroup = bgroup->second.find(i.first);
            //if ( qualified && inbgroup != bgroup->second.end() && IsReserved(*(inbgroup->second))) {
            if ( qualified && inbgroup != bgroup->second.end()) {
                at0 ++;
                if (IsReserved(*(inbgroup->second)) && IsReserved(*i.second)) reserved_at0 ++;
                if (at0 >= count && reserved_at0 >= std::min(1,count)) return true;
                //if (at0 >= count) return true;
            }
        } else {
            assert (end == 1);
            bool qualified = false;
         
            if (exceeding) {
                if (i.second->SameDirect()) {
                    qualified = i.second->a_.id == a ? i.second->b_.len - i.second->b_.end > max_overhang_ 
                                                     : i.second->a_.len - i.second->a_.end > max_overhang_;
                } else {
                    qualified = i.second->a_.id == a ? i.second->b_.start > max_overhang_ 
                                                     : i.second->a_.start > max_overhang_;
                }
            } else {
                qualified = i.second->a_.id == a ? i.second->a_.len - i.second->a_.end <= max_overhang_ 
                                                 : i.second->b_.len - i.second->b_.end <= max_overhang_;
            }
            auto inbgroup = bgroup->second.find(i.first);
            //if ( qualified && inbgroup != bgroup->second.end() && IsReserved(*(inbgroup->second))) {
            if ( qualified && inbgroup != bgroup->second.end()) {
                at1 ++;
                if (IsReserved(*(inbgroup->second)) && IsReserved(*i.second)) reserved_at1 ++; 
                if (at1 >= count && reserved_at1 >= std::min(1,count)) return true;
                //if (at1 >= count) return true;
            }
        }
    }

    return false;
}

std::unordered_set<const Overlap*> OverlapFilter::FindBestN(const std::pair<int, std::unordered_map<int, const Overlap*>> &g) const {
    std::unordered_set<const Overlap*> keep;
    std::vector<const Overlap*> left, right;
    for (auto &i : g.second) {
        const Overlap& o = *(i.second);

        if (IsReserved(o)) {
            auto loc = o.Location(i.first, 0);
            if (loc == Overlap::Loc::Left) {
                left.push_back(&o);
            } else {
                assert(loc == Overlap::Loc::Right);
                right.push_back(&o);
            }
            
        }
    }

    if (left.size() > (size_t)bestn_) {
        std::sort(left.begin(), left.end(), [](const Overlap* a, const Overlap *b){ return BetterAlignedLength(*a, *b); });

        keep.insert(left.begin(), left.begin() + bestn_);
    }
    else {
        keep.insert(left.begin(), left.end());
    }
    if (right.size() > (size_t)bestn_) {
        std::sort(right.begin(), right.end(), [](const Overlap* a, const Overlap *b) { return BetterAlignedLength(*a, *b);} );

        keep.insert(right.begin(), right.begin() + bestn_);

    }
    else {
        keep.insert(right.begin(), right.end());
    }

    return keep;
}

bool OverlapFilter::IsContained(const Overlap& o, std::array<int, 2> &rel) {
    auto loc = o.Location(0);
    if (loc == Overlap::Loc::Contained || loc == Overlap::Loc::Containing || loc == Overlap::Loc::Equal) {
        //  contained = rel[0], contain = rel[1]

        if (loc == Overlap::Loc::Equal) {
            rel[0] = std::max(o.a_.id, o.b_.id);
            rel[1] = std::min(o.a_.id, o.b_.id);
        }
        else if (loc == Overlap::Loc::Contained) {
            rel[0] = o.a_.id;
            rel[1] = o.b_.id;
        }
        else {
            assert(loc == Overlap::Loc::Containing);
            rel[0] = o.b_.id;
            rel[1] = o.a_.id;
        }
        return true;

    } else {
        return false;
    }

}


bool OverlapFilter::IsSupportContained(const Overlap& o, const std::array<int, 2> &rel) {
    int left_sup = 0, left_all = 0;
    int right_sup = 0, right_all = 0;
    auto group0 = groups_.find(rel[0]);
    auto group1 = groups_.find(rel[1]);
    for (auto i : group0->second) {

        const Overlap &o = *i.second;

        if (IsReserved(o)) {
            const Overlap::Read& r = o.a_.id == rel[0] ? o.b_ : o.a_;
            auto l = o.Location(r.id, 0);


            if (l == Overlap::Loc::Left || l == Overlap::Loc::Containing) {
                left_all ++;
                if (group1->second.find(r.id) != group1->second.end()) {
                    left_sup ++;
                }
            }

            if (l == Overlap::Loc::Right || l == Overlap::Loc::Containing) {
                right_all ++;
                if (group1->second.find(r.id) != group1->second.end()) {
                    right_sup ++;
                }

            }
        }
    }

    if ((left_all == 0 || left_sup > 0) && (right_all == 0 || right_sup>0)) {
        return true;
    } else {
        return false;
    } 
}

void OverlapFilter::UpdateFilteredRead(const std::unordered_map<Seq::Id, RdReason> &ignored) {

    for (const auto &o : ol_store_.Get()) {
        if (IsReserved(o)) {
            auto it = ignored.find(o.a_.id);
            if (it == ignored.end()) it = ignored.find(o.b_.id);

            if (it != ignored.end()) {
                SetOlReason(o, OlReason::FilteredRead(it->first));
            }
        }
    }
}


std::unordered_set<Seq::Id> OverlapFilter::ReservedReads() {
    std::unordered_set<Seq::Id> reserved;

    for (const auto &o : ol_store_.Get()) {
        if (GetOlReason(o).type == OlReason::RS_OK) {
            reserved.insert(o.a_.id);
            reserved.insert(o.b_.id);
        }
    }

    return reserved;
}


void OverlapFilter::Dump() const {
    DumpCoverage(OutputPath(coverage_fname_));
    DumpFilteredReads(OutputPath(filtered_read_fname));
    DumpFilteredOverlaps(OutputPath(filtered_overlap_fname));
    ol_store_.GetReadStore().SaveIdToName(OutputPath("filter_id2name.txt.gz"));
}

void OverlapFilter::DumpCoverage(const std::string &fname) const {
    gzFile of = gzopen(fname.c_str(), "w");
    if (of != nullptr) {
        for (auto c : coverages_) {
            //of << c.first << " " << c.second[0] << " " << c.second[1] << " " <<  c.second[1] -  c.second[0] << "\n";
            gzprintf(of, "%d %d %d %d\n", c.first, c.second[0], c.second[1], c.second[1] -  c.second[0]);
        }
        gzclose(of);
    } else {
        LOG(ERROR)("Fail to open coverage file %s", fname.c_str());
    }
}

void OverlapFilter::DumpFilteredReads(const std::string &fname) const {
    
    std::unordered_map<RdReason::Type, std::string, std::hash<int>> type_strs = {
        { RdReason::RS_CONTAINED, "Contained" },
        { RdReason::RS_COVERAGE, "Coverage" },
        { RdReason::RS_NO_LONGEST, "NoLongest" },
    };

    gzFile of = gzopen(fname.c_str(), "w");
    if (of != nullptr) {
        for (auto r : filtered_reads_) {
            gzprintf(of, "%d %s %d %d\n", r.first, type_strs[r.second.type].c_str(), r.second.sub[0], r.second.sub[1]);
            //of << r.first << " " << type_strs[r.second.type] << " " << r.second.sub[0] << " " 
            //   << r.second.sub[1] << "\n";
        }
        gzclose(of);

    } else {
        LOG(ERROR)("Fail to open filterd reads file %s", fname.c_str());
    }
}

void OverlapFilter::DumpFilteredOverlaps(const std::string &fname) const {
    std::unordered_map<OlReason::Type, std::string, std::hash<int>> type_strs = {
        { OlReason::RS_SIMPLE, "Simple" },
        { OlReason::RS_DUPLICATE, "Duplicate" },
        { OlReason::RS_BESTN, "BestN" },
        { OlReason::RS_FILTERED_READ, "FilteredRead" },
        { OlReason::RS_LACK_OF_SUPPORT, "LackOfSupport" },
        { OlReason::RS_LOCAL, "Local" },
        { OlReason::RS_UNKNOWN, "Unknown" },
    };

    gzFile of = gzopen(fname.c_str(), "w");
    if (of != nullptr) {
        for (const auto &o : ol_store_.Get()) {
            OlReason rs = GetOlReason(o);
            if (rs.type != OlReason::RS_OK) {
                gzprintf(of, "%d %d %s %d %d\n", o.a_.id+1, o.b_.id+1, type_strs[rs.type].c_str(), rs.sub[0], rs.sub[1]);
                //of << o.a_.id + 1<< " " << o.b_.id + 1<< " " << type_strs[rs.type] << " " << rs.sub[0] << " "  // TODO id
                //<< rs.sub[1] << "\n";

            }
        }
        gzclose(of);
    } else {
        LOG(ERROR)("Fail to open filterd reads file %s", fname.c_str());
    }
}

void OverlapFilter::DumpReadInfos(const std::string &fname, const std::unordered_map<int, ReadStatInfo> &readInfos) const {
    
    gzFile of = gzopen(fname.c_str(), "w");
    if (of != nullptr) {
        for (auto &i : readInfos) {
            gzprintf(of, "%d %d %f %d %d %f %f %f\n", i.first, i.second.len, i.second.identity, i.second.overhang, i.second.count, 
                i.second.identity_threshold, i.second.overhang_l_threshold, i.second.overhang_r_threshold);
            //of << i.first << " " << i.second.len << " " << i.second.identity << " "  << i.second.overhang << " " << i.second.count << "\n";
        }
        gzclose(of);
    } else {
        LOG(ERROR)("Fail to open ReadInfos file %s", fname.c_str());
    }
}

void OverlapFilter::SetOlReason(const Overlap &o, OlReason rs) {
    o.attached = ((long long)(rs.type) << 32) + rs.sub[0];
    assert(rs.sub[1] == 0);
}

OverlapFilter::OlReason OverlapFilter::GetOlReason(const Overlap &o) {
    OlReason rs; 
    rs.type = (OlReason::Type)(o.attached >> 32);
    assert(rs.type >= OlReason::RS_OK && rs.type <= OlReason::RS_UNKNOWN);

    rs.sub[0] = o.attached & 0xFFFFFFFF;
    return rs;
}


bool OverlapFilter::ParamToGenomeSize(const std::string& str, long long *v) {
    
    //std::regex pattern("(\\d+)([gGmMkK]?)");
    //std::smatch m;
    //bool r = std::regex_match(str, m, pattern);
    //if (r) {
    //    *v = atoll(m.str(1).c_str());
    //    *v *= m.str(2) == "k" || m.str(2) == "K" ? 1024 :
    //          m.str(2) == "m" || m.str(2) == "M" ? 1024*1024 :
    //          m.str(2) == "g" || m.str(2) == "G" ? 1024*1024*1024 : 1;
    //}
    //return r;
    *v = atoll(str.c_str());
    return true;
}

int OverlapFilter::Percentile(const std::vector<int> &data, double percent) {
    assert(0 <= percent && percent <= 100);

    auto minmaxv = std::minmax_element(data.begin(), data.end());

    auto minv = (*minmaxv.first);
    auto maxv = (*minmaxv.second);

    std::vector<int> counts(maxv-minv+1, 0);
    for (auto c : data) {
        counts[c-minv]++;
    }
    
    int accu = 0;
    for (size_t i=0; i<counts.size(); ++i) {
        accu += counts[i];
        if (data.size() * percent / 100 <= accu) {
            return i + minv;
        }
    }
    return maxv;
}

int OverlapFilter::FirstTrough(const std::vector<int> &data, size_t last, size_t k) {
    assert(k % 2 == 1 && data.size() >= k);

    auto minmaxv = std::minmax_element(data.begin(), data.end());

    auto minv = (*minmaxv.first);
    auto maxv = (*minmaxv.second);

    std::vector<int> counts(maxv-minv+1, 0);
    for (auto c : data) {
        counts[c-minv]++;
    }
    
    // calc the starting poistion
    size_t s = 0;
    for (size_t i=1; i<last/10; ++i) {
        if (counts[i-1] > counts[i]) {
            s = i - 1;
            break;
        }
    }

    int value = std::accumulate(counts.begin()+s, counts.begin()+s+k, 0);
    std::pair<size_t, int> best(s, value);
    for (size_t i=s+1; i<counts.size()+k-1 && i<last; ++i) {
        value += -counts[i-1] + counts[i+k-1];
        if (value < best.second*1.00) {
            best.first = i;
            best.second = value;
        } else {
            //best.first = i;
            //best.second = value;
            break;
        }
    }

    assert(best.first >= s);
    size_t bestbest = best.first;
    for (auto i=bestbest+1; i<best.first+k; ++i) {
        if (counts[i] < counts[bestbest]) bestbest = i;
    }

    for (auto i=(size_t)std::max(0, (int)best.first-(int)k); i<best.first+k; ++i) {
        if (counts[i] - counts[bestbest] <= counts[bestbest]*0.30) {
            bestbest = i; 
            break;
        }
    }
    return bestbest;
}

} // namespace fsa {
